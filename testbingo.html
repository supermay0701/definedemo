<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Bingo äºŒéšé‡åŒ–å›æ¸¬ç³»çµ± 3.0</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0f172a; color: #f8fafc; padding: 20px; }
        .container { max-width: 1200px; margin: auto; }
        .panel { background: #1e293b; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border: 1px solid #334155; }
        button { background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold; transition: 0.2s; }
        button:hover { background: #2563eb; }
        input { padding: 8px; border-radius: 4px; border: 1px solid #475569; background: #0f172a; color: white; width: 60px; font-size: 16px; text-align: center;}
        .stats { display: flex; justify-content: space-around; margin-top: 15px; font-size: 1.1em; background: #0f172a; padding: 15px; border-radius: 8px; border: 1px solid #334155;}
        .markov { color: #f59e0b; } .streak { color: #06b6d4; } .random { color: #94a3b8; }
        .prediction-box { display: flex; gap: 20px; margin-top: 20px; }
        .pred-card { flex: 1; background: #0f172a; padding: 15px; border-radius: 8px; text-align: center; border: 1px solid #334155;}
        .pred-numbers { font-size: 1.5em; font-weight: bold; margin-top: 15px; letter-spacing: 2px;}
        .ball { display: inline-block; width: 35px; height: 35px; line-height: 35px; border-radius: 50%; background: #e2e8f0; color: #0f172a; margin: 0 3px; font-size: 0.65em;}
        .desc { font-size: 0.8em; color: #64748b; margin-top: 10px;}
    </style>
</head>
<body>
    <div class="container">
        <h2>Bingo é«˜éšæ¢ä»¶æ©Ÿç‡å›æ¸¬å¼•æ“ 3.0</h2>
        <div class="panel">
            <label>æŠ“å–è¿‘ <input type="number" id="fetchDays" value="5"> å¤©æ­·å²æ•¸æ“š</label>
            <label style="margin-left: 20px;">æ»‘å‹•è¨“ç·´çª—å£: <input type="number" id="windowSize" value="300" style="width: 70px;"> æœŸ</label>
            <button style="margin-left: 20px;" onclick="runBacktest()">å•Ÿå‹•é«˜ç¶­åº¦å›æ¸¬</button>
            <p id="status" style="color: #94a3b8; font-size: 0.9em; margin-top: 15px;">ç­‰å¾…æŒ‡ä»¤... (é‹ç®—æœƒæ¶ˆè€—æ‚¨çš„é›»è…¦ CPUï¼Œè«‹è€å¿ƒç­‰å¾…)</p>
        </div>
        
        <div class="panel" id="predictionPanel" style="display: none;">
            <h3 style="margin-top: 0; color: #f8fafc; border-bottom: 1px solid #334155; padding-bottom: 10px;">ğŸ¯ æ¬¡æœŸä¸‹æ³¨å»ºè­° (åŸºæ–¼ç•¶å‰é–‹å‡ºè™Ÿç¢¼çš„æ¢ä»¶æ¨ç®—)</h3>
            <div class="prediction-box">
                <div class="pred-card">
                    <div class="markov">ğŸ”— é¦¬å¯å¤«æ‹–ç‰Œç­–ç•¥</div>
                    <div class="desc">æ­·å²æ•¸æ“šé¡¯ç¤ºï¼Œç•¶å‰è™Ÿç¢¼æœ€å¸¸å¸¶å‡ºçš„è·Ÿå±èŸ²</div>
                    <div class="pred-numbers" id="predMarkov"></div>
                </div>
                <div class="pred-card">
                    <div class="streak">ğŸ§² é€£èŠå­˜æ´»å‹•èƒ½ç­–ç•¥</div>
                    <div class="desc">å¾ç•¶å‰é–‹å‡ºè™Ÿç¢¼ä¸­ï¼ŒæŒ‘é¸æ­·å²é€£èŠç‡æœ€é«˜çš„ç•™å–®</div>
                    <div class="pred-numbers" id="predStreak"></div>
                </div>
            </div>
        </div>

        <div class="panel">
            <canvas id="backtestChart" width="1000" height="400"></canvas>
            <div class="stats" id="finalStats"></div>
        </div>
    </div>

    <script>
        // ğŸš¨ æ›¿æ›ç‚ºä½ çš„ GAS Web App URL
        const API_URL = "https://script.google.com/macros/s/AKfycbxmeB5viK8rZz1UgAHu1BwjKISTjOM_TiNddi00sl6SMzfKIT0hRz2HPtprld942VF3/exec"; 
        let chartInstance = null;

        function formatBalls(arr) {
            return arr.map(num => `<span class="ball">${num < 10 ? '0'+num : num}</span>`).join('');
        }

        async function runBacktest() {
            const statusEl = document.getElementById('status');
            const days = parseInt(document.getElementById('fetchDays').value);
            const windowSize = parseInt(document.getElementById('windowSize').value);
            
            // è½‰æ›å¤©æ•¸ç‚ºæœŸæ•¸ (ä¸€å¤©ç´„ 204 æœŸ)
            const limit = days * 205; 
            
            statusEl.innerText = `æ­£åœ¨å¾é›²ç«¯æå–è¿‘ ${days} å¤© (ç´„ ${limit} æœŸ) çš„è³‡æ–™...`;
            document.getElementById('predictionPanel').style.display = 'none';

            try {
                const response = await fetch(`${API_URL}?limit=${limit}`);
                const resJson = await response.json();
                if (!resJson.success) throw new Error(resJson.error);
                
                const data = resJson.data;
                if (data.length <= windowSize) {
                    statusEl.innerText = `ğŸš¨ éŒ¯èª¤ï¼šè³‡æ–™é‡ä¸è¶³ã€‚å¯¦éš›å–å¾— ${data.length} æœŸï¼Œä½†è¨“ç·´çª—å£è¨­å®šç‚º ${windowSize} æœŸã€‚è«‹å¢åŠ æŠ“å–å¤©æ•¸ï¼Œæˆ–æ¸›å°è¨“ç·´çª—å£ã€‚`;
                    return;
                }

                statusEl.innerText = `âœ… æˆåŠŸè¼‰å…¥ ${data.length} æœŸè³‡æ–™ã€‚é–‹å§‹åŸ·è¡Œ O(N*W) äºŒéšæ¢ä»¶çŸ©é™£é‹ç®—...`;
                
                // ä½¿ç”¨ setTimeout è®“ç€è¦½å™¨æœ‰æ™‚é–“å…ˆæ¸²æŸ“ä¸Šè¿°æ–‡å­—ï¼Œå†é€²å…¥é«˜è€—èƒ½é‹ç®—
                setTimeout(() => executeStrategies(data, windowSize), 50);
                
            } catch (error) {
                statusEl.innerText = `ğŸš¨ é€£ç·šéŒ¯èª¤: ${error.message}`;
            }
        }

        // æ ¸å¿ƒæ¼”ç®—æ³• 1: æ‹–ç‰Œæ¢ä»¶æ©Ÿç‡
        function getMarkovPrediction(history, currentDraw) {
            let nextCounts = new Array(81).fill(0);
            for (let i = 0; i < history.length - 1; i++) {
                let prev = history[i].numbers;
                let next = history[i+1].numbers;
                // æ‰¾å‡ºæ­·å²ä¸Šè©²æœŸèˆ‡ã€Œç•¶å‰è™Ÿç¢¼ã€æœ‰å¹¾é¡†é‡ç–Š
                let matchWeight = currentDraw.filter(n => prev.includes(n)).length;
                if (matchWeight > 0) {
                    // ä¸‹ä¸€æœŸé–‹å‡ºçš„è™Ÿç¢¼ï¼Œçµ¦äºˆç›¸æ‡‰çš„æ¬Šé‡åˆ†æ•¸
                    next.forEach(num => nextCounts[num] += matchWeight);
                }
            }
            // æ’åºåˆ†æ•¸ï¼Œå–å‡ºå‰5å
            let indices = Array.from({length: 80}, (_, i) => i + 1);
            return indices.sort((a, b) => nextCounts[b] - nextCounts[a]).slice(0, 5);
        }

        // æ ¸å¿ƒæ¼”ç®—æ³• 2: é€£èŠè¡°æ¸›åˆ†æ
        function getStreakPrediction(history, currentDraw) {
            let survivalRates = {};
            currentDraw.forEach(num => {
                let appearCount = 0;
                let survivedCount = 0;
                for (let i = 0; i < history.length - 1; i++) {
                    if (history[i].numbers.includes(num)) {
                        appearCount++;
                        if (history[i+1].numbers.includes(num)) survivedCount++;
                    }
                }
                survivalRates[num] = appearCount > 0 ? (survivedCount / appearCount) : 0;
            });
            // å¾ç•¶å‰çš„ 20 é¡†çƒä¸­ï¼ŒæŒ‘é¸æ­·å²å­˜æ´»ç‡æœ€é«˜çš„å‰ 5 é¡†
            return [...currentDraw].sort((a, b) => survivalRates[b] - survivalRates[a]).slice(0, 5);
        }

        // åŸºæº–ç·š: é–‰çœ¼ççŒœ
        function getRandomPrediction() {
            let nums = [];
            while(nums.length < 5) {
                let r = Math.floor(Math.random() * 80) + 1;
                if(!nums.includes(r)) nums.push(r);
            }
            return nums;
        }

        function executeStrategies(data, windowSize) {
            let labels = [];
            let markovHitsData = [];
            let streakHitsData = [];
            let randomHitsData = [];
            
            let hits = { markov: 0, streak: 0, random: 0 };
            
            // æ­·å²å›æ¸¬è¿´åœˆ
            for (let i = windowSize; i < data.length; i++) {
                const historyWindow = data.slice(i - windowSize, i); // è¨“ç·´é›†
                const currentDraw = data[i-1].numbers; // æœ¬æœŸè™Ÿç¢¼ (åšç‚ºæ¨ç®—åŸºæº–)
                const targetDraw = new Set(data[i].numbers); // ä¸‹ä¸€æœŸçœŸå¯¦é–‹ç (ç­”æ¡ˆ)
                labels.push(data[i].id);

                const markovPred = getMarkovPrediction(historyWindow, currentDraw);
                const streakPred = getStreakPrediction(historyWindow, currentDraw);
                const randomPred = getRandomPrediction();

                hits.markov += markovPred.filter(n => targetDraw.has(n)).length;
                hits.streak += streakPred.filter(n => targetDraw.has(n)).length;
                hits.random += randomPred.filter(n => targetDraw.has(n)).length;

                markovHitsData.push(hits.markov);
                streakHitsData.push(hits.streak);
                randomHitsData.push(hits.random);
            }

            // å¯¦æˆ°é æ¸¬æœ€æ–°ä¸‹ä¸€æœŸ
            const latestHistory = data.slice(data.length - windowSize);
            const absoluteCurrentDraw = data[data.length - 1].numbers; // å‰›é–‹å‡ºçš„æœ€æ–°ä¸€æœŸ
            
            const nextMarkov = getMarkovPrediction(latestHistory, absoluteCurrentDraw);
            const nextStreak = getStreakPrediction(latestHistory, absoluteCurrentDraw);

            document.getElementById('predMarkov').innerHTML = formatBalls(nextMarkov);
            document.getElementById('predStreak').innerHTML = formatBalls(nextStreak);
            document.getElementById('predictionPanel').style.display = 'block';

            const totalPredictions = (data.length - windowSize) * 5; 
            document.getElementById('finalStats').innerHTML = `
                <div class="markov">ğŸ”— æ‹–ç‰Œæ¢ä»¶å‹ç‡: ${((hits.markov / totalPredictions)*100).toFixed(2)}%</div>
                <div class="streak">ğŸ§² é€£èŠå­˜æ´»å‹ç‡: ${((hits.streak / totalPredictions)*100).toFixed(2)}%</div>
                <div class="random">ğŸ² ççŒœåŸºæº–ç·š: ${((hits.random / totalPredictions)*100).toFixed(2)}% (ç†è«–å€¼25%)</div>
            `;
            document.getElementById('status').innerText = "âœ… çŸ©é™£é‹ç®—å®Œæˆï¼å…¨æ–°ç¶­åº¦åœ–è¡¨å·²æ¸²æŸ“ã€‚";

            renderChart(labels, markovHitsData, streakHitsData, randomHitsData);
        }

        function renderChart(labels, markovData, streakData, randomData) {
            const ctx = document.getElementById('backtestChart').getContext('2d');
            if (chartInstance) chartInstance.destroy();
            
            chartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: 'ğŸ”— æ‹–ç‰Œç­–ç•¥ç´¯ç©å‘½ä¸­', data: markovData, borderColor: '#f59e0b', backgroundColor: 'transparent', tension: 0.3, pointRadius: 0, borderWidth: 2 },
                        { label: 'ğŸ§² é€£èŠç­–ç•¥ç´¯ç©å‘½ä¸­', data: streakData, borderColor: '#06b6d4', backgroundColor: 'transparent', tension: 0.3, pointRadius: 0, borderWidth: 2 },
                        { label: 'ğŸ² åŸºæº–ç·š (é–‰çœ¼ççŒœ)', data: randomData, borderColor: '#475569', borderDash: [5, 5], backgroundColor: 'transparent', tension: 0.3, pointRadius: 0, borderWidth: 1 }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { display: true, title: { display: true, text: 'æœŸæ•¸æ¨é€²', color: '#94a3b8' }, ticks: { color: '#94a3b8', maxTicksLimit: 20 } },
                        y: { display: true, title: { display: true, text: 'ç´¯ç©å‘½ä¸­çƒæ•¸', color: '#94a3b8' }, ticks: { color: '#94a3b8' } }
                    },
                    plugins: { legend: { labels: { color: '#f8fafc' } } }
                }
            });
        }
    </script>
</body>
</html>
